## Python

```
      Python:                                                 APL:
      x=arange(1,5)                                          x←⍳4
      x
array([1,2,3,4])
      sum(x)                                                 +/x
10
      add(x,x)                                               x+x
array([2,4,6,8])
      add.reduce(x)   ⍝'reduce'-в apl расставляет            +/x
      ф-цию (add 1(элемент) add 2 add 3
```

Импорт (from numpy import*)

```
      m=add.outer([2,1]x)    ⍝'outer'-внешнее произведение   2 1 ∘.+x
      m                                                       m
array([[3,4,5,6],[2,3,4,5]])                                  3 4 5 6
                                                              2 3 4 5
      sum(m)                                                  +/m
32
      add.reduce(m)                                          +/[1]m  ⍝+⌿m
array([5,7,9,11])
      add/reduce(m,axis=1)   ⍝'axis'-ось                     +/m  ⍝по строкам
array([18,14])
      multiply.reduce(m,axis=1)                               ×/m  ⍝по строкам
array([360,120])
      shape(m)                                                ⍴m
(2,4)
      m.shape
(2,4)
      m1=m                                                    m1←4 2 ⍴m 
      m1.shape=[4,2]   ⍝транспанирование
      m1
array([[3,4],
       [5,6],
       [2,3],
       [4,5]])
      vstack((m,m))   ⍝конкретинируем по одному измерению    m,[1]m
array([[3 4 5 6],
       [2 3 4 5],
       [3 4 5 6],
       [2 3 4 5]])
      mm=vstack((m,m))                                        mm←m,[1]m
      mm.shape                                                ⍴mm
(4,4)
      mm=hstack((m,m))                                        mm←m,m
      mm
array([[3,4,5,6,3,4,5,6],                                     3 4 5 6 3 4 5 6
       [2,3,4,5,2,3,4,5]])                                    2 3 4 5 2 3 4 5
      mm.shape                                                ⍴mm
(2,8)
      x
array([[1 2 3 4 ]])
```

Перемножение по правилу линейной алгебры

```
      x
1 2 3 4
      m1
3 4
5 6
2 3
4 5
      dot(x,m1)                                               x+.×m1
35 45
```

from numpy import *

```
def med3(x):
     y = vstack((x[:-2],x[1:-1],x[2:]))
     y = y.sum(axis=0)-(y.min(axis=0)+y.max(axis=0))
     return hstack((x[0],y,x[-1]))

def hann(x):
     y = 0.25*x[:-2]+0.5*x[1:-1]+0.25*x[2:]
     return hstack((x[0],y,x[-1]))
```

На APL:

**Сглаживание выборки** - это преобразование значений выборки таким образом, чтобы
уменьшить их разброс относительно соседних с целью выявления основной тенденции их
поведения.

*Крайние значения, не подвергшиеся обработке, заменяются ближайшим преобразованным значением.*

**Ганнирование** - это сглаживание путём замены каждого значения выборки на взвешенное
среднее между ним и двумя соседними, причём вес при основном значении в 2 раза больше
веса соседних.

![20181109](/home/ekaterina/Desktop/AO/Лекция 4/20210305.png)

![20210305(1)](/home/ekaterina/Desktop/AO/Лекция 4/20210305(1).png)

**Формула в APL:**

```
hann←{1⌽x[⌽1,⍴x],x←.25 .5 .25+.×⍉⊃3,/⍵}
```

Примеры сглаживания ганнированием:

Мы создали синусоиду и зашумили её:

```
]load stat
#.stat
      ]load plt
#.plt
      ⎕path← 'plt stat'
t←0,.1×⍳200
s←1○0,.1×⍳200
sd←s+.3×stat.rnd ⍴s
sd←sd-0.15
1 0 1 plot t s sd (hann sd)
```

![20210305(2)](/home/ekaterina/Desktop/AO/Лекция 4/20210305(2).BMP)

#### Сглаживание медианой по тройкам

1. Мы берём 3 последовательно расположенных значения выборки.
2. Находим медиану (это будет одно из этих значений).
3. Заменяем центральное значение этой медианой.

***Формула в APL:***

```
med3←{(+/m)-(⌈/m)+⌊/m←⊃3,/⍵}
1 0 1 plot t s sd (med3 sd)
```

![20210305(3)](/home/ekaterina/Desktop/AO/Лекция 4/20210305(3).BMP)

**Замечание.** В случае наличия выброса при ганнировании искажаются точки, соседние с
выбросом, в то время как медиана по тройкам просто отбрасывает его.
