# Метод главных компонент (PCA)

Математически обоснованный метод. Это классика, он присутствует как программа во всех без исключения пакетах и библиотеках для всех языков в том числе для Python, R.

Есть система координат в n-мерном пространстве

<img src="/home/ekaterina/Desktop/AO/Лекция 7/1.PNG" style="zoom:80%;" />

и эти координатные оси обладают свойствами:

1. ​	перпендикулярны друг к другу;
2. ​	<img src="/home/ekaterina/Desktop/AO/Лекция 7/3.PNG" style="zoom:80%;" /> ;
3. ​	каждая из осей имеет длину = 1  <img src="/home/ekaterina/Desktop/AO/Лекция 7/2.PNG" style="zoom:80%;" /> .

В этой системе координат у нас задано N точек, каждая точка задана вектором.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/4.PNG" style="zoom:80%;" />

Мы эти векторы:

1. отцентрировали, т.е. вычли из них среднее по всем векторам, т.о. среднее стало равно 0, стрелка над нулем обозначает, что это n штук нулей, это вектор состоящий из нулевых координат.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/5.PNG" style="zoom:80%;" />

2. отнормировали на длину, каждое  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_i.PNG" style="zoom:70%;" /> 	разделили на сумму квадратов и т.о. длина каждого векторочка стала равна 1

<img src="/home/ekaterina/Desktop/AO/Лекция 7/6.PNG" style="zoom:80%;" />

Вводится понятие веса каждой оси и под весом понимается дисперсия проекции на эту ось всех наших точек, т.е. суммирование идет по j от единицы до N, <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_i.PNG" style="zoom: 70%;" /> – одна и та же ось для которой мы вычисляем вес, а  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_j.PNG" style="zoom:70%;" /> бегает по всем векторочкам.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/7.PNG" style="zoom:80%;" />

Среднее для проекции будет равно 0, поэтому мы его не вычитаем из  <img src="/home/ekaterina/Desktop/AO/Лекция 7/7.1.png" style="zoom:67%;" /> , остается сумма квадратов проекций.

Нас волнует на сколько эти веса неравномерно распределены или наоборот – равномерно по осям координат и мерой равномерности/неравномерности является энтропия, т.е. суммы весов умноженные на логарифмы весов в принципе, т.к. мы будем для разных систем координат считать энтропию, нам напревать по какому основанию логарифм берется, но т.к. энтропия считалась ранее для бинарных данных и связывалась информацией передаваемой по каналу и там был двоичный логарифм, то и мы для определенности будем использовать двоичный.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/8.PNG" style="zoom:80%;" />

Чем меньше энтропия, тем более неравномерно распределены веса координат.

Переходим к решению.

Доказывается математически, что минимуму энтропии соответствует система координат составленная из собственных векторов ковариационной матрицы.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/9.PNG" style="zoom:25%;" /> , где **С** – ковариационная матрица.

Если мы умножаем какой-то вектор на матрицу, то мы получаем другой вектор в общем случае, который не совпадает с первым, не только по длине, а самое главное по направлению.

Если речь идет о собственном векторе, то его умножение на матрицу эквивалентно умножению его на какой-то скаляр, т.е. у этого вектора останется то же направление, как у исходного, изменится длина в зависимости от того, кто такой **λ** и **λ** называется собственным числом, а  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e.PNG" style="zoom: 18%;" /> – собственный вектор.

Если мы вычислим у квадратной матрицы **n**x**n** имеется n штук разных собственных векторов, каждому из которых соответствует свое собственное число. 

Когда все **n** собственных векторов определим  <img src="/home/ekaterina/Desktop/AO/Лекция 7/1.PNG" style="zoom:70%;" /> . Расположим их в порядке убывания собственных чисел  <img src="/home/ekaterina/Desktop/AO/Лекция 7/10.PNG" style="zoom:60%;" /> , а перед тем, как располагать, обратим внимание на то, что собственное число равно дисперсии проекций на соответствующую ось  <img src="/home/ekaterina/Desktop/AO/Лекция 7/7.2.PNG" style="zoom:60%;" /> , отбросим k штук с наименьшими весами, т.е. имеющие наименьшие собственные числа, то ошибка представления исходного множества точек может быть записано в процентах <img src="/home/ekaterina/Desktop/AO/Лекция 7/12.PNG" style="zoom:60%;" />(сумму от 1 до (n-k) – сколько у нас осталось собственных чисел, делим на сумму всех собственных чисел, умножим на 100, вот это вот в процентах наша ошибочка представления исходных данных.)

**Рассмотрим примеры:**

Есть ковариационная матрица, чтобы не мучиться с коэффициентами ковариации, мы рассмотрим корреляционную матрицу <img src="/home/ekaterina/Desktop/AO/Лекция 7/13.PNG" style="zoom:60%;" />, т.е. у нас двумерное пространство  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:70%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_2.PNG" style="zoom:70%;" /> , есть какой-то набор **Х** и коэф. корреляции между  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_1.PNG" style="zoom:67%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_2.PNG" style="zoom:67%;" /> = 1, так получилось.

Записываем ур-е для собственного числа и вектора

<img src="/home/ekaterina/Desktop/AO/Лекция 7/9.PNG" style="zoom:18%;" />

Переносим содержащее неизвестное в левую часть выносим  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e.PNG" style="zoom:18%;" /> , которое присутствует в обоих слагаемых за скобочки. Т.к. у нас остался скаляр **λ**, мы не можем его просто отнять от матрицы С, в линейной алгебре, если надо отнять скаляр, то он отнимается от диагональных элементов матрицы. Поэтому **λ** умножим на **I**, где **I** – единичная матрица(по диагонали единицы, вне диагонали нули)  <img src="/home/ekaterina/Desktop/AO/Лекция 7/14.PNG" style="zoom: 65%;" /> .

Если мы это дела раскроем, то получим систему линейных ур-ний, относительно неизвестных нам <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:70%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_2.PNG" style="zoom:70%;" /> и неизвестного **λ**, эта система однородная (правые части равны 0). Чтобы однородная система имела решение, ее определитель должен = 0, т.е.  <img src="/home/ekaterina/Desktop/AO/Лекция 7/15.PNG" style="zoom:65%;" /> .

Расписываем:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/16.PNG" style="zoom:60%;" />

**(С-λI)** в нашем случае =  <img src="/home/ekaterina/Desktop/AO/Лекция 7/16.1.PNG" style="zoom:50%;" /> , теперь считаем определитель этой матрицы. Произведение по основной диагонали это <img src="/home/ekaterina/Desktop/AO/Лекция 7/16.2.png" style="zoom:60%;" /> минус произведение по дополнительной диагонали (это 1), и это все равно 0.

Решаем получившееся квадратное ур-е, видим два решения:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/17.PNG" style="zoom:50%;" />

Сколько у нас разных неизвестных? Две штуки, потому что размерность пространства у нас 2, размер матрицы ковариационной 2х2. Отсюда два собственных числа получились.

Подставляем первое **λ** в систему ур-ний <img src="/home/ekaterina/Desktop/AO/Лекция 7/18.PNG" style="zoom:65%;" /> и решаем ее

<img src="/home/ekaterina/Desktop/AO/Лекция 7/19.PNG" style="zoom:60%;" />

Этой системе из двух ур-ний с двумя неизвестными удовлетворяет любое  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:70%;" /> =  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_2.PNG" style="zoom:70%;" /> =const.

Теперь обозначим **const** как **с**  (<img src="/home/ekaterina/Desktop/AO/Лекция 7/20.PNG" style="zoom:70%;" />) и вот первый собственный вектор  <img src="/home/ekaterina/Desktop/AO/Лекция 7/21.PNG" style="zoom:65%;" />.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/22.png" style="zoom:80%;" />

Как определять как брать **С**? Глубоко плевать, но для определенности возьмем его таким, чтоб длина   <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:70%;" /> =1.

Разделим **С** на длину   <img src="/home/ekaterina/Desktop/AO/Лекция 7/21.PNG" style="zoom:60%;" /> =с^2+c^2=2c^2, извлекаем корень с2^.5, поделим на длину все компоненты, получим  <img src="/home/ekaterina/Desktop/AO/Лекция 7/23.PNG" style="zoom:60%;" />

Проверка APL:

```
      (2 2⍴1)+.×,['']÷2 2*.5
1.414213562
1.414213562
      ÷2 2*.5
0.7071067812 0.7071067812
      2×÷2 2*.5
1.414213562 1.414213562
```

Теперь подставляем второе λ = 0, ищем второй собственный вектор аналогично первому.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/24.PNG" style="zoom:70%;" />

Получаем два линейных ур-ния:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/25.PNG" style="zoom:60%;" />

<img src="/home/ekaterina/Desktop/AO/Лекция 7/26.PNG" style="zoom:60%;" />

Решение - та же константа, то с противоположными знаками

<img src="/home/ekaterina/Desktop/AO/Лекция 7/27.PNG" style="zoom:60%;" />

<img src="/home/ekaterina/Desktop/AO/Лекция 7/28.PNG" style="zoom:60%;" />

<img src="/home/ekaterina/Desktop/AO/Лекция 7/29.PNG" style="zoom:60%;" />

Проверка на APL:

```
      (2 2⍴1)+.×,['']1 ￣1×÷2 2*.5
0
```

Что такое единичная корреляционная матрица, и что такое собственные числа 2 и 0, и что такое собственные векторы  <img src="/home/ekaterina/Desktop/AO/Лекция 7/29.1.PNG" style="zoom:60%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/29.2.PNG" style="zoom:60%;" /> ?

<img src="/home/ekaterina/Desktop/AO/Лекция 7/30.png" style="zoom:70%;" />

Как будут лежать точки  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_1.PNG" style="zoom:60%;" /> , <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_2.PNG" style="zoom:60%;" />  для **ρ**<img src="/home/ekaterina/Desktop/AO/Лекция 7/x_1.PNG" style="zoom:60%;" /><img src="/home/ekaterina/Desktop/AO/Лекция 7/x_2.PNG" style="zoom:60%;" />=1?

<img src="/home/ekaterina/Desktop/AO/Лекция 7/31.png" style="zoom:80%;" />

Они лежат на прямой под углом 45 градусов.

Т.е. <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_2.PNG" style="zoom:60%;" /> =0+1(коэф.наклона) х  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_1.PNG" style="zoom:60%;" />=<img src="/home/ekaterina/Desktop/AO/Лекция 7/x_1.PNG" style="zoom:60%;" />

Далее, среднее у них после центрирования = 0, соответственно коэф. корреляции равен <img src="/home/ekaterina/Desktop/AO/Лекция 7/32.png" style="zoom:90%;" /> и это будет  <img src="/home/ekaterina/Desktop/AO/Лекция 7/33.png" style="zoom:80%;" />

Если мы посчитаем проекции на  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:60%;" /> , опустим их так, что если сначала они были под 45 градусов, теперь будут под 0 градусов.  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_2.PNG" style="zoom:60%;" /> перпендикулярный к  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:60%;" /> . Все проекции на  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_2.PNG" style="zoom:60%;" /> будут равны 0.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/34.png" style="zoom:90%;" />

Значит мы можем, если **k** возьмем = 1, т.е. отбросим λ=0, то сумма от единицы до **(n-k)** будет равно 2, сумма от 1 до n =2+0=2, соответственно 2/2x100%=100%, то бишь оставляя первый собственный вектор соответствующий собственному числу мы сохраняем 100% информации о взаимном распределении точек, ничего не теряем. Действительно, накий пес нам играть в две координаты  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_1.PNG" style="zoom:60%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_2.PNG" style="zoom:60%;" /> , если проекция на  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:60%;" />- одномерная и все расстояния между точками сохраняются, мы видим всю структуру.

**Пример 2:**

Корреляционная матрица диагональная. Т.е. коэф. корреляции между  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_1.PNG" style="zoom:60%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_2.PNG" style="zoom:60%;" /> = 0. Соответственно, вычисление аналогично:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/35.PNG" style="zoom:60%;" />

Решением будет:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/36.PNG" style="zoom:60%;" />

Находим собственные векторы, подставляя первое λ, матрица становится нулевой:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/37.PNG" style="zoom:60%;" />

Соответственно любые  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:60%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_2.PNG" style="zoom:60%;" /> будут удовлетворять: 

<img src="/home/ekaterina/Desktop/AO/Лекция 7/38.PNG" style="zoom:60%;" />

Единственное, что нас волнует, это то, что эти вектора <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_1.PNG" style="zoom:60%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/e_2.PNG" style="zoom:60%;" /> должны быть перпендикулярны между собой:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/40.png" style="zoom:100%;" />

**ρ=0,** т.е. точки распределены, грубо говоря, внутри какого-то круга и когда мы считаем 1,2,3,4-квадранты, получаем сумму (X1i x X2i), т.к. у нас  <img src="/home/ekaterina/Desktop/AO/Лекция 7/39.png" style="zoom:70%;" /> , то в первом квадранте у нас будет ''+'' на ''+'', получим большое положительное, в третьем квадранте будет ''–'' на ''–'' тоже большое положительно число, во втором и четвертом квадрантах ''+'' на ''–'' получим большое отрицательное число.

Итого: положительное(1квадрант)+отрицательное(2квадрант)+ положительное (3квадрант) + отрицательное(4квадрант) = 0

И относительно этого нуля, как не крути систему координат, ничего не изменится!

И если снова обратимся к нашему ур-нию в выкинем теперь второе λ = 1, то 1/(1+1) х 100% =50%

Выкидывая любую из координат  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_1.PNG" style="zoom:60%;" /> и  <img src="/home/ekaterina/Desktop/AO/Лекция 7/x_2.PNG" style="zoom:60%;" /> , мы теряем 50% информации о распределении наших точек. Например проектируем на красную ось, во все, кто выше или ниже, а вот самые удаленные друг от друга точки сольются в одну точку.

**Рассмотрим искусственный примерчик о температурном поле:**

Есть реактор, где у нас 1, 2,...., 10 термопары на выходе и какое-то поле, слева холоднее, справа горячее. 

<img src="/home/ekaterina/Desktop/AO/Лекция 7/41.png" style="zoom:100%;" />

Если мы в разные моменты времени проведем измерения, то это поле сохраняя распределение, что слева холоднее, справа горячее, может еще быть все больше, все меньше, т.е. оно не меняя распределения по термопарам, а средняя температура может быть то больше, то меньше.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/42.png" style="zoom:100%;" />

Функция которая на APL возвращает три результата:

а1 – собственные числа

b1 – матрица собственных векторов 

c1 – матрица проекций на собственные вектора исходных данных, в данном случае х1.

```
      x1←⍳10
      x1←⊃(⊂x1)+⍳16
      (a1 b1 c1)←mds.(COVM SELFIC)x1
```

Во-первых, нам очень интересно, какие получились первые 10 чисел

```
      a1
212.5 0 0 0 0 0 0 0 0 0
```

Т.к. матрица ковариационная, то собственные числа нецелочисленные и получилось, что одно собственное число 212.5 отличается от 0, все остальные равны 0.

Если мы отбросим 9 собственных векторов и оставим один, который соответствует первому собственному числу, которое не нулевое. Мы сохраним 100% информации(212.5/(212.5+0+0+0+0+0+0+0+0+0)х100%).

Во-вторых, нам интересно посмотреть на первый собственный вектор, что это за голубь на который мы должны проектировать?

```
      b1[;1]
¯0.316227766 ¯0.316227766 ¯0.316227766 ¯0.316227766 ¯0.316227766
¯0.316227766 ¯0.316227766 ¯0.316227766 ¯0.316227766 ¯0.316227766
```

Первое, что мы должны, что все компоненты этого собственного вектора в 10-мерном пространстве равны между собой по модулю и просто равны. Второе, они все отрицательные, ну и плевать, то бишь, проекции на этот собственный вектор будет (-0.316227766)хТ1+(-0.316227766)хТ2+…+(-0.316227766)хТ10, т.е., если рассматривать эти 0.316227766 несмотря на минус, как веса, то получаем, что в качестве проекции  у нас взвешенное с этими весами, одинаковыми сумма всех наших термопар, которые определяют на сколько у нас отличается среднее значение температуры. Т.е. на самом деле у нас не 10-мерное пространство, а одномерное, где средний ур-нь меняется.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/43.png" style="zoom:100%;" />

Теперь рассмотрим видоизмененный этот пример, где у нас меняется не только средний уровень, но и распределение, т.е.:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/42.1.png" style="zoom:100%;" />

В каком-то эксперименте мы одно наблюли, в другом — другое и т.д.

Т.е. у нас меняются две вещи:

1. средняя температура;

2. распределение температур (слева — холодно, справа — горячо или наоборот).

Для этого случая посчитаем собственные числа и векторы.

Во-первых, мы видим, что у нас два собственных числа не равны 0 (первое число и второе число), остальные = 0. Мы можем безболезненно, не теряя информации, понизить нашу размерность пространства с 10-мерной до 2-мерной.

```
      x2←⍳10
      x2←⊃(⊂x2)×∊2⍴⊂⍳8
      x2[⍳8;]←⌽x2[⍳8;]
      (a2 b2 c2)←mds.(COVM SELFIC)x2
      a2
2103.75 1588.125 2.479131558E¯13 8.187234765E¯14 6.036530033E¯14 1.97029597E¯14 1.239658888E¯14 ¯3.340844541E¯14 ¯5.933993521E¯14 ¯1.555394639E¯13
```

Во-вторых, очень интересно на какие собственные векторы мы будем проектировать:

```
      b2[;⍳2]
0.4954336943        ¯0.316227766
0.3853373178        ¯0.316227766
0.2752409413        ¯0.316227766
0.1651445648        ¯0.316227766
0.05504818826       ¯0.316227766
¯0.05504818826      ¯0.316227766
¯0.1651445648       ¯0.316227766
¯0.2752409413       ¯0.316227766
¯0.3853373178       ¯0.316227766
¯0.4954336943       ¯0.316227766
```

Начнем со второго. Второй нам даст, при проектировании 10-ти термопарок, опять видим одинаковые множители, т.е. он даст аналог средней температуры на выходе.

А вот первый поинтереснее, мы видим, что первая компонента, соответствующая первой термопаре имеет какое-то положительное значение, а последняя компонента (10-ая термопара) имеет точно такое же по модулю значение, но отрицательное, т.е. когда мы начнем проектировать, мы из первой термопары умноженной на 0.4954336943 вычтем 10-ую умноженную на 0.4954336943, т.е. получим первое минус десятое, эта разность будет характеризовать перекос поля:

<img src="/home/ekaterina/Desktop/AO/Лекция 7/44.png" style="zoom:100%;" />

Теперь идя к центру реактора, сохраняется одинаковость весов и противоположность знаков, но по модулю эти веса убывают, это связано с тем, что в середине реактора не зависимо от наклона у нас маленькие изменения, а по краям — большие изменения в зависимости от направления поля. 5 и 6 термопары будут иметь минимальный вес, а крайние — максимальный, это перекос. Первое собственное число = перекос, второе собственное число = среднее значение поля.

<img src="/home/ekaterina/Desktop/AO/Лекция 7/45.png" style="zoom:100%;" />